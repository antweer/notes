Intro

- Cryptographic Hash Function
  - Mathematical function that takes any string as input, creates a fixed-size output, efficiently computable
  - Security properties:
    - collision-free
      - nobody can find x and y such that x != y and H(x) = H(y)
        - distinction is not that collissions don't exist but rather they cant be found - more inputs possible than outputs
        - Find a collision by picking 2^130 randomly chosen inputs, 99.8% chance theres some that collide
          - Doesn't matter because of how long it takes to get to that step
          - Odds of finding it if every computer computed this since the beginning of time, odds will still be infinitesimally small
      - No hash function in history that has proven to be collision free
      - If we know H(x) = H(y), it's safe to assume that x = y
        - Hashes useful as a message digest
    - Hiding
      - Given H(x), it is infeasible to find x
      - If r is chosen from a probability distribution that has high min-entropy, then given H(r | x), it is infeasible to find x
        - High min-entropy means that the distribution is very spread out, so that no particular value is chosen with more than negligible probability
      - Application: commitment
        - Want to seal a value in an envelope and open the envelope later
          - commit to a value, reveal it later
        - (com, key) := commit(msg)
        - match := verify(com, key, msg)
        - To seal msg in envelope:
          - (com, key) := commit(msg) then pulis com
        - To open envelope:
          - publish key, msg
          - anyone can use verify() to check if msg true
        - Security properties:
          - Hiding: given com, infeasible to find msg
          - Binding: infeasible to fing msg != msg' such that verify(commit(msg), msg') == true
      - Commitment API
    - Puzzle friendly
      - For every possible output value y, if k is chosen from a distribution with high-min entropy, then it is infeasible to find x such that H(k | x) = y
      - Application: search puzzle
        - Given a "puzzle id" and a target set Y:
          - Try to find a "solution" x such that H(id | x) in Y
        - Puzzle friendly property implies that no solving strategy is better than trying random values of x
  - SHA-256 Hash Function
    - Takes the message you're hashing and breaks it into blocks and adds padding to it to make it fit so that length is a multiple of 512 bit block size then computes Hash
      - Takes each 512 bit block and runs it through c function
- Hash pointer
  - pointer to where some info is stored and cryptographic hash of the info
  - if we have a pointer, we can ask to get the info back and verify the data hasn't changed
  - Drawn as H ( ) with arrow coming out of it
  - Build data structures with hash pointers instead of pointers
  - Block chain has a tamper-evident log due to hash pointers
    - if an adversary changes the content of an earlier block, the hash changes since its collission free
  - Binary tree with hash pointers is a "Merkle Tree"
    - Proving membership in a Merkle tree, show O(log n) items (just the particular chain) instead of entire tree
    - Advantages
      - tree holds many items but just need to remember the root has
      - can verify membership in O(log n) time
      - variant: sorted MErkle tree
        - allows us to verify non-membership in O(log n)
          - show items before, after the missing one
  - Can use hash pointers in anu pointer based data structure as long as they aren't cyclical
- Digital Signatures
  - Like a signature on paper but in digital form
    - Only you can sign, but anyone can verify
    - Tied to a particular document, cant be cut and pasted to another doc
  - API
    - (sk, pk) := generateKeys(keysize)
      - sk is secret signing key
      - pk is public verification key
    - sig := sign(sk, message)
    - Above can be randomized algorithms
    - isVAlid := verify(pk, message, sig)
      - Boolean function
      - Can't be randomized since it's deterministic
    - valid signatures verify
      - verify(pk, message, sign(sk, message)) == true
    - can't forge signatures
    - adversary who knows pk and message can't forge signature
  - Algorithms are randomized so you need a good source of randomness
    - attacks on randomness are a good trick by intelligence agencies
  - Limit on message sizie
    - fix: use Hash(message) rather than message
  - Fun trick: sign a hash pointer
    - then the signature will cover the entire content of the chain
  - Bitcoin uses ECDSA standard
    - Elliptic Curve Digital Signature Algorithm
    - Math for it is complex
    - good randomness is essential
      - if you mess this up, you've leaked your private key
- Public keys as identities
  - Take a public key from digital signature scheme and equate that to an identity
  - IF you see sig such that verify(pk, msg, sig)==true
    - think of it as pk says, "msg"
    - to speak for pk, you must know match secret key sk
      - Since only you know the sk, there is an identity in the system that only you can speak for
  - New identity
    - create a new random key pair (sk, pk)
      - pk is the public "name" you can use
        - better to use Hash(pk) usually
      - sk lets you speak for the identity
  - Decentralized identity management
    - anyone can make a new identy at any time and you can have as many as you want
      - How bitcoin does identity (addresses)
        - pk or hash of pk
    - Privacy
      - addresses not directly connected to realworld id
      - but observer can link together an address's activity over time to make inferences
      - Bitcoin privacy lecture later
- Simple cryptocurrency
  - GoofyCoin
    - Goofy can create new coins
      - signed by pkgoofy
      - CreateCoin [uniqueCoinID]
    - A coin's owner can spend it
      - signed by pkgoofy
      - pay to pkAlice:H( )
        - signed by pkgoofy
        - CreateCoin[uniqueCoinID]
          - Now alice owns it and she can spend it and give it to someone else
    - Security concern
      - Alice can give coin to 2 people
        - double-spending attack
          - one of the key problems a cryptourrency must solve but GoofyCoin doesnt
          - the main design challenge in making a cryptocurrency
            - ScroogeCoin will fix this
  - ScroogeCoin
    - Scrooge publishes a history of all transactions
      - a block chain, signed by Scrooge
        - optimization would be to put multiple transactions in the same block
      - Now if Alice tries to give the coin to Bob and Chuck both, everyone will know it's a double spend and will reject it
      - Each coin has a number, value, recipient
        - number is the transaction index in the block
        - id(number) points to transaction ID and the index of transaction
    - PayCoins transaction consumesand destroys some coins and creates new coins of the same total value
      - valid if consumed coins valid, not already consumed, total value out = total value in, and signed by owners of all consumed coins
        - validity allows it to be written into history
        - coins are immutable
          - but you get the same effect through transaction
            - can't subsdivide 1 coin but can have a transaction where 1 coin is consumed and a 2/3 coin is created
    - Core problem:
      - Scrooge - if he starts misbehaving or gets bored of the scheme then the system wont operate anymore
      - i.e it is centralized currency
        - Can we descroogify the currency and operate without any central, trusted authority?
          - If we can solve this problem then we can build a currency like bitcoin
